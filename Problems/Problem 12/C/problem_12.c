#include <time.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
/**
 * Problem 12 from Project Euler
 *
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
 * 
 *  1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *  1: 1
 *  3: 1,3
 *  6: 1,2,3,6
 *  10: 1,2,5,10
 *  15: 1,3,5,15
 *  21: 1,3,7,21
 *  28: 1,2,4,7,14,28
 *
 *  We can see that 28 is the first triangle number to have over five divisors.
 *  What is the value of the first triangle number to have over five hundred divisors?
 *
 *  PLEASE NOTE
 *  In order to compile you must have gcc, or similar, installed
 *
 *  REGARDING THE PERFORMANCE
 *  This is not the final version of the script, everyone can improve it. If you have a better solution
 *  please submit a pull request or an issue on Github.
 *
 *  @author Claudio Ludovico Panetta (@Ludo237)
 *
 *  @version 1.1:.0
 **/
#define ITERATION 500

/**
 * isPrime
 * @param const unsigned int number - Number to check is prime
 * @return bool
 * @description
 *  Check if a given number is prime
 **/
bool isPrime(const unsigned int number);
/**
 * isSquare
 * @param const unsigned int number - Given number
 * @return unsigned int
 * @description
 *  Check if a given number is "Square", if not return 0
 **/
unsigned int isSquare(const unsigned int number);
/**
 * divisible
 * @param unsigned int number - Given number
 * @return unsigned int
 * @description
 **/
unsigned int divisible(unsigned int number);

int main(int argc, char* argv[])
{
    // Benchmark variables
    double start, end;
    // Helper variables
    unsigned int i = 1, summatory = 0;
    // Algorithm start
    start = clock();
    // Algorithm start
    do
    {
        summatory += i++;
        if( divisible(summatory) > ITERATION)
            break;
    }while(true);
    // Algorithm end
    end = clock();
    printf("Algorithm end, Time: %f\n", (end - start)/CLOCKS_PER_SEC);
    printf("%d\n", summatory);
    return 0;
}

bool isPrime(const unsigned int number) // This should reduce the complexity by a factor of O(n^1/2)
{
    if( number == 1 || (number % 2 == 0))
        return false;
    if( number == 2)
        return true;
    for(unsigned short int i = 3; i <= sqrt(number); i+=2)
    {
        if(number % i == 0) return false;
    }
    return true;
}

unsigned int isSquare(const unsigned int number) // This function should have a complexity of O(1)
{
    unsigned int temp = sqrt(number);
    if(temp * temp == number) return temp;
    return 0;
}

unsigned int divisible(unsigned int number) // Actually I don't analize the complexity of this one... lol
{
    int temp, i = 1, j = 2, result = 1;
    if(number == 1)
        return 1;
    if(isPrime(number))
        return 2;
    if(temp == isSquare(number) != 0)
        return temp + 1;
    while(number != 1)
    {
        temp = pow(j,i);
        if(number % temp == 0)
            i++;
        else
        {
            result *= i;
            --i;
            number /= pow(j, i);
            i = 1; 
            ++j;
        }
    }
    return result;
}

