#include <time.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdint.h>
/**
 * Problem 44 from Project EulerPentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
 *
 * 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
 *
 * It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
 *
 * Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?
 * 
 * PLEASE NOTE
 * In order to compile you must have gcc, or similar, installed
 *
 * REGARDING THE PERFORMANCE
 * This is not the final version of the Algorithm, anyone can improve it.
 * If you have a better solution please submit a pull request, or ani issue, on Github.
 *
 * @author Claudio Ludovico Panetta (@Ludo237)
 *
 * @version 1.0.0
 **/

/**
 * is_pentagonal
 * @param intmax_t 
 * @return int
 * @description
 *  Check if a given number is pentagonal
 **/
int is_pentagonal (intmax_t num)
{
    /*
     * Solving P = n(3n - 1) / 2 for n, we get
     * n = (1 + sqrt (1 + 24P)) / 6
     * So P is pentagonal if 1 + 24P is a square and sqrt (1 + 24P) + 1 is
     * divisible by 6, i.e. sqrt (1 + 24P) modulo 6 is 5.
     */
    double sqrdiscr = sqrt (1 + 24 * num);
    return sqrdiscr == (double) (intmax_t) sqrdiscr && (intmax_t) sqrdiscr % 6 == 5;
}

int main ()
{
    // Benchmark variable
    double start, end;
    // Helper variables
    int isNot;
    intmax_t smallestDiff = LONG_MAX;
    intmax_t j, k = 1;
    intmax_t Pj, Pk = 1;
    // Start
    start = clock();
    printf("Algorithm starts, please wait...\n");
    do
    {
        j = 0;
        Pj = 0;
        isNot = 1;
        Pk += k + k + k + 1;
        ++ k;
        do
        {
            Pj += j + j + j + 1;
            ++ j;
        } while (j < k && (isNot = (!is_pentagonal (Pj + Pk) || !is_pentagonal (Pk - Pj))));
        if (!isNot && Pk - Pj < smallestDiff)
            smallestDiff = Pk - Pj;
        // Stop when adhacent pentagonals become larger than D
    } while (isNot && Pk - Pj < smallestDiff);
    // End 
    end = clock();
    printf("Algorithm end.\n");
    printf("Total time: %f\n", (end - start)/CLOCKS_PER_SEC);
    return 0;
}
